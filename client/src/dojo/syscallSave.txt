import { SetupNetworkResult } from "./setupNetwork";
import {
  Account,
  InvokeTransactionReceiptResponse,
  shortString,
  Event
} from "starknet";
import {
  EntityIndex,
  getComponentValue,
  setComponent, Components, Schema
} from "@latticexyz/recs";
import { uuid } from "@latticexyz/utils";
import { ClientComponents } from "./createClientComponents";
import { CAMERA_ID, GAME_ID, MAP_HEIGHT, MAP_WIDTH} from "../phaser/constants";
import { poseidonHashMany } from "micro-starknet";
import { hexToAscii } from "../utils";


// THIS SCRIPT WILL REPLACE THE OLD ONE 


export type SystemCalls = ReturnType<typeof createSystemCalls>;

export function createSystemCalls(
  { execute, contractComponents }: SetupNetworkResult,
  {
    Position,
    Defence,
    Lifes,
    Prosperity,
    Name,
    Game,
    WorldEvent,
    Balance,
    Ownership,
    GameTracker,
    GameData,
    OutpostEntity,

    ClientCameraPosition,
    ClientClickPosition
  }: ClientComponents
) {


  const reinforce_outpost = async (signer: Account, entity_id: number) => {

    const entityId = getEntityIdFromKeys([BigInt(entity_id), BigInt(signer.address),BigInt(GAME_ID)]);

    const defenceId = uuid();
    Defence.addOverride(defenceId, {
      entity: entityId,
      value: {
        plague: (getComponentValue(Defence, entityId)?.plague || 0) + 1,
      },
    });

    const lifeId = uuid();
    Lifes.addOverride(lifeId, {
      entity: entityId,
      value: {
        count: (getComponentValue(Lifes, entityId)?.count || 0) + 1,
      },
    });

    try {
      const tx = await execute(signer, "reinforce_outpost", [
        entity_id,
        GAME_ID,
      ]);

      const receipt = await signer.waitForTransaction(tx.transaction_hash, {
        retryInterval: 100,
      });

      setComponentsFromEvents(contractComponents, getEvents(receipt));

    } catch (e) {
      console.log(e);
      Defence.removeOverride(defenceId);
      Lifes.removeOverride(lifeId);
    } finally {
      Defence.removeOverride(defenceId);
      Lifes.removeOverride(lifeId);
    }
  };





  // THIS IS TO REDO
  const destroy_outpost = async (signer: Account, entity_id: number) => {

    const entityId = getEntityIdFromKeys([BigInt(entity_id), BigInt(signer.address),BigInt(GAME_ID)]);

    const defenceId = uuid();
    Defence.addOverride(defenceId, {
      entity: entityId,
      value: {
        plague: (getComponentValue(Defence, entityId)?.plague || 0) - 1,
      },
    });

    const lifeId = uuid();
    Lifes.addOverride(lifeId, {
      entity: entityId,
      value: {
        count: (getComponentValue(Lifes, entityId)?.count || 0) - 1,
      },
    });

    try {
      const tx = await execute(signer, "reinforce_outpost", [
        entity_id,
        GAME_ID,
      ]);

      const receipt = await signer.waitForTransaction(tx.transaction_hash, {
        retryInterval: 100,
      });

      setComponentsFromEvents(contractComponents, getEvents(receipt));

    } catch (e) {
      console.log(e);
      Defence.removeOverride(defenceId);
      Lifes.removeOverride(lifeId);
    } finally {
      Defence.removeOverride(defenceId);
      Lifes.removeOverride(lifeId);
    }
  };





  const register_player = async (signer: Account) => {
  
    const entityId = getEntityIdFromKeys([BigInt(GAME_ID), BigInt(signer.address)])

    const gameDataId = uuid();
    GameData.addOverride(gameDataId, {
      entity: entityId,
      value: {count_outposts: 10},
    });

    try {
      const tx = await execute(signer, "register_player", [GAME_ID]);

      const receipt = await signer.waitForTransaction(tx.transaction_hash, {
        retryInterval: 100,
      });

      setComponentsFromEvents(contractComponents, getEvents(receipt));

    } 
    catch (e) {
      console.log(e);
      GameData.removeOverride(gameDataId);
    } finally {
      GameData.removeOverride(gameDataId);
    }
  };





  const create_outpost = async (
    signer: Account,
    game_id: number,
    outpost_num: number
  ) => {

    // the key made here does not match what should it be in the ndojo side life is only gmae id and outpost id not signer address
    
    const entityId = getEntityIdFromKeys([BigInt(outpost_num), BigInt(signer.address),BigInt(GAME_ID)])
    
    console.log("the created enithyt id of the outpost is: ", entityId);

    const lifesId = uuid();
    Lifes.addOverride(lifesId, {
      entity: entityId,
      value: { },
    });

    const defenceId = uuid();
    Defence.addOverride(defenceId, {
      entity: entityId,
      value: {},
    });

    const nameId = uuid();
    Name.addOverride(nameId, {
      entity: entityId,
      value: {},
    });

    const prosperityId = uuid();
    Prosperity.addOverride(prosperityId, {
      entity: entityId,
      value: {},
    });

    const positionId = uuid();
    Position.addOverride(positionId, {
      entity: entityId,
      value: {},
    });

    const ownershipId = uuid();
    Ownership.addOverride(ownershipId, {
      entity: entityId,
      value: {},
    });

    const outpostEntityId = uuid();
    OutpostEntity.addOverride(outpostEntityId, {
      entity: entityId,
      value: {},
    });

    try {
      const tx: any = await execute(signer, "create_outpost", [game_id]);

      const receipt = await signer.waitForTransaction(tx.transaction_hash, {
        retryInterval: 100,
      });

      setComponentsFromEvents(contractComponents, getEvents(receipt));

    } catch (e) {
      console.log(e);
      Lifes.removeOverride(lifesId);
      Defence.removeOverride(defenceId);
      Name.removeOverride(nameId);
      Prosperity.removeOverride(prosperityId);
      Position.removeOverride(positionId);
      Ownership.removeOverride(ownershipId);
      OutpostEntity.removeOverride(outpostEntityId);
    } finally {
      Lifes.removeOverride(lifesId);
      Defence.removeOverride(defenceId);
      Name.removeOverride(nameId);
      Prosperity.removeOverride(prosperityId);
      Position.removeOverride(positionId);
      Ownership.removeOverride(ownershipId);
      OutpostEntity.removeOverride(outpostEntityId);
    }
  };

  const create_game = async (signer: Account) => {

    const cameraId = CAMERA_ID as EntityIndex;

    const clientCamCompId = uuid();
    ClientCameraPosition.addOverride(clientCamCompId, {
      entity: cameraId,
      value: { x:MAP_WIDTH/2,y:MAP_HEIGHT/2 },
    });

    const clickCompId = uuid();
    ClientClickPosition.addOverride(clickCompId, {
      entity: cameraId,
      value: { 
        xFromMiddle: 0, 
        yFromMiddle: 0,
        
        yFromOrigin: 0, 
        xFromOrigin: 0 
      },
    });


    const gameId = GAME_ID as EntityIndex;

    const gameCompId = uuid();
    Game.addOverride(gameCompId, {
      entity: gameId,
      value: { },
    });


    const entityId = 999999999999999 as EntityIndex;

    const gameTrackerId = uuid();
    GameTracker.addOverride(gameTrackerId, {
      entity: entityId,
      value: {},
    });

    try {
      const tx = await execute(signer, "create_game", []);

      console.log(tx);
      const receipt = await signer.waitForTransaction(tx.transaction_hash, {
        retryInterval: 100,
      });

      console.log("this is for the game", receipt);
      setComponentsFromEvents(contractComponents, getEvents(receipt));

    } catch (e) {
      console.log(e);
      Game.removeOverride(gameCompId);
      GameTracker.removeOverride(gameTrackerId);
      ClientClickPosition.removeOverride(clickCompId);
      ClientCameraPosition.removeOverride(clientCamCompId);
    } finally {
      Game.removeOverride(gameCompId);
      ClientClickPosition.removeOverride(clickCompId);
      ClientCameraPosition.removeOverride(clientCamCompId);
      GameTracker.removeOverride(gameTrackerId);
    }
  };

  const set_world_event = async (signer: Account) => {
    
    const entityId = getEntityIdFromKeys([BigInt(GAME_ID), BigInt(signer.address), BigInt(50)])
    
    const worldEventId = uuid(); 
    WorldEvent.addOverride(worldEventId, {
      entity: entityId,
      value: {},
    });

    const positionId = uuid();
    Position.addOverride(positionId, {
      entity: entityId,
      value: {},
    });

    try {
      const tx = await execute(signer, "set_world_event", [GAME_ID]);

      const receipt = await signer.waitForTransaction(tx.transaction_hash, {
        retryInterval: 100,
      });

      setComponentsFromEvents(contractComponents, getEvents(receipt));
     
    } catch (e) {
      console.log(e);
      WorldEvent.removeOverride(worldEventId);
      Position.removeOverride(positionId);
    } finally {
      WorldEvent.removeOverride(worldEventId);
      Position.removeOverride(positionId);
    }
  };















  const set_click_component = async (xOrigin: number, yOrigin: number, xMiddle: number, yMiddle:number) => 
  {
    const entityId = CAMERA_ID as EntityIndex;

    const defenceId = uuid();
    ClientClickPosition.addOverride(defenceId, {
      entity: entityId,
      value: {
        xFromMiddle: xMiddle, 
        yFromMiddle: yMiddle,
        
        yFromOrigin: yOrigin, 
        xFromOrigin: xOrigin 
      },
    });
  }


  const set_camera_position_component = async (x: number, y: number) => 
  {
    const entityId = CAMERA_ID as EntityIndex;

    const defenceId = uuid();
    ClientCameraPosition.addOverride(defenceId, {
      entity: entityId,
      value: {
        x: x, y: y, 
      },
    });
  }

  return {
    reinforce_outpost,
    create_game,
    create_outpost,
    register_player,
    destroy_outpost,
    set_world_event,

    set_camera_position_component,
    set_click_component
  };
}



export function getEvents(receipt: any): any[] {
  return receipt.events.filter((event: any) => {
      return event.keys.length === 1 &&
          event.keys[0] === import.meta.env.VITE_EVENT_KEY;
  });
}

export function setComponentsFromEvents(components: Components, events: Event[]) {
  events.forEach((event) => setComponentFromEvent(components, event.data));
}

export function setComponentFromEvent(components: Components, eventData: string[]) {
  // retrieve the component name
  const componentName = hexToAscii(eventData[0]); 

  const component = components[componentName];

  const keysNumber = parseInt(eventData[1]); //number of keys
  
  let index = 2 + keysNumber + 1;  // this is the index to get the number of vars

  const keys = eventData.slice(2, 2 + keysNumber).map((key) => BigInt(key));

  const entityIndex = getEntityIdFromKeys(keys);

  let numberOfValues = parseInt(eventData[index++]);

  const values = eventData.slice(index, index + numberOfValues);
  
  const componentValues = Object.keys(component.schema).reduce((acc: Schema, key, index) => {
      const value = values[index];
      acc[key] = Number(value);
      return acc;
  }, {});

  setComponent(component, entityIndex, componentValues);
}

export function getEntityIdFromKeys(keys: bigint[]): EntityIndex {
  if (keys.length === 1) {
    return parseInt(keys[0].toString()) as EntityIndex;
  }
  // calculate the poseidon hash of the keys
  let poseidon = poseidonHashMany([BigInt(keys.length), ...keys]);
  return parseInt(poseidon.toString()) as EntityIndex;
}